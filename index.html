<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.6.0/d3.js"></script>
    <script>
        d3.csv('data.csv').then(data => {

            const genreArray = [];

            data.forEach(d => {
                d.rating = +d.rating;
                //generate option genre 
                var genreSplit = d.genre.split(',');
                for( i = 0; i < genreSplit.length; i++){
                    if(!genreArray.includes(genreSplit[i])){
                        genreArray.push(genreSplit[i].trim())
                    }
                }
            })

            //genre selection
            const select = d3.select('body').append('select').attr('class','genre');

            const option = select.selectAll('option').data(genreArray).enter().append('option');

            option.text(d => d).attr('value', d => d)

            //rating selection
            const ratingSelection = d3.select('body').append('select').attr('class','rating');

            const ratingOption = ratingSelection.selectAll('option').data(Array.from(Array(10).keys())).enter().append('option');

            ratingOption.text(d => d).attr('value', d => d);


            // sorting data
            data = data.sort(function(a, b) {
                return parseFloat(b.rating) - parseFloat(a.rating);
            });

            //store original data assets
            var originalData = data;

            ratingDefault = 2;
            genreDefault = 'Action';
            limitData = 20;

            //get data filtered by rating default
            

            let newData = data.filter(function(d,i){
                    
                    return d.rating > ratingDefault && d.genre.includes(genreDefault);                    
            });


            //output limited data
            newData = newData.slice(0, limitData);


            //chart 
            const chartWidth = 960,
                chartHeight = 1000;

            const margin = {top : 50, left: 200, right : 30, bottom: 30};

            const innerWidth = chartWidth - margin.left - margin.right;
            const innerHeight = chartHeight - margin.top - margin.bottom;

            const space = d3.select('body').append('svg')
                                    .attr('width', chartWidth)
                                    .attr('height', chartHeight);

            //real dimension of the chart
            let chart = space.append('g')
                        .attr('class' , 'gruppo')
                        .attr('width', innerWidth)
                        .attr('height', innerHeight)
                        .attr('transform', `translate ( ${margin.left} , ${margin.top})`);  
            
            let xScale = d3.scaleLinear()
                            .domain([0,d3.max(data, d => d.rating)])
                            .range([0, innerWidth]).nice();
                            
            let xAxis = d3.axisBottom(xScale);
            chart.append('g')
                    .call(xAxis)
                    .attr('transform',`translate(0, ${innerHeight})`)

            let yScale = d3.scaleBand()
                            .domain(data.map(d => d.name))
                            .range([0, innerHeight])
                            .padding(0.1);

            let yAxis = d3.axisLeft(yScale);
            chart.append('g').call(yAxis).attr('class', 'yLine');


            //function draw 
            const render = (selection, data) => {

                //update axis
                xScale.domain([0,d3.max(data, d => d.rating)]);
                yScale.domain(data.map(d => d.name));

                chart.select('.yLine').call(yAxis);

                const rectangles = chart.selectAll('rect').data(data);

                rectangles.enter().append('rect')
                            .transition()
                            .duration(500)
                            .attr('width', d => xScale(d.rating))
                            .attr('height', yScale.bandwidth())
                            .attr('y', d => yScale(d.name))

                //update rect
                rectangles.transition()
                            .duration(500).attr('width', d => xScale(d.rating))
                            .attr('height', yScale.bandwidth())
                            .attr('y', d => yScale(d.name))

                rectangles.exit().remove();

            }

            render( chart, newData);

            var newRating = ratingDefault;
            var newGenre = genreDefault;
            var newLimit = limitData;

            //option selected
            d3.select('.genre').on('change', function(){

                newGenre = this.value;
                console.log(newGenre)

                var minRating = newRating;
                minRating = minRating.toFixed(2)
                console.log('min',minRating)

                let filteredData = data.filter(function(d,i){
                    
                    return d.rating > newRating  && d.genre.includes(newGenre);

                });

                filteredData = filteredData.slice(0, limitData);

                console.log(filteredData)

                render( chart, filteredData);
            })

            //option selected
            d3.select('.rating').on('change', function(){

                var minRating = +this.value;
                minRating = minRating.toFixed(2)
                console.log('min',minRating)

                var maxRating = +minRating + 1;
                maxRating = maxRating.toFixed(2)
                console.log('max',maxRating)

                console.log(newGenre)

                let filteredData = data.filter(function(d){
                
                    return d.rating > minRating  && d.genre.includes(newGenre);

                });

                filteredData = filteredData.slice(0, limitData);

                console.log(filteredData)

                render( chart, filteredData);
            })

        })
    </script>
    
</body>
</html>